package main

import (
	"encoding/json"
	"math/big"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/common/hexutil"
)

type supplyInfoIssuance struct {
	GenesisAlloc *big.Int `json:"genesisAlloc,omitempty"`
	Reward       *big.Int `json:"reward,omitempty"`
	Withdrawals  *big.Int `json:"withdrawals,omitempty"`
}

//go:generate go run github.com/fjl/gencodec -type supplyInfoIssuance -field-override supplyInfoIssuanceMarshaling -out gen_supplyinfoissuance.go
type supplyInfoIssuanceMarshaling struct {
	GenesisAlloc *hexutil.Big
	Reward       *hexutil.Big
	Withdrawals  *hexutil.Big
}

type supplyInfoBurn struct {
	EIP1559 *big.Int `json:"eip1559,omitempty"`
	Blob    *big.Int `json:"blob,omitempty"`
	Misc    *big.Int `json:"misc,omitempty"`
}

//go:generate go run github.com/fjl/gencodec -type supplyInfoBurn -field-override supplyInfoBurnMarshaling -out gen_supplyinfoburn.go
type supplyInfoBurnMarshaling struct {
	EIP1559 *hexutil.Big
	Blob    *hexutil.Big
	Misc    *hexutil.Big
}

// supplyInfo is the structure of the supply data
// as generated by the supply tracer at go-ethereum
type supplyInfo struct {
	Delta    *big.Int            `json:"delta"`
	Issuance *supplyInfoIssuance `json:"issuance,omitempty"`
	Burn     *supplyInfoBurn     `json:"burn,omitempty"`

	// Block info
	Number     uint64      `json:"blockNumber"`
	Hash       common.Hash `json:"hash"`
	ParentHash common.Hash `json:"parentHash"`
}

// getCalculatedDelta calculates the supply delta
func (s *supplyInfo) getCalculatedDelta() *big.Int {
	delta := big.NewInt(0)
	if s.Issuance != nil {
		if s.Issuance.GenesisAlloc != nil {
			delta.Add(delta, s.Issuance.GenesisAlloc)
		}
		if s.Issuance.Reward != nil {
			delta.Add(delta, s.Issuance.Reward)
		}
		if s.Issuance.Withdrawals != nil {
			delta.Add(delta, s.Issuance.Withdrawals)
		}
	}
	if s.Burn != nil {
		if s.Burn.EIP1559 != nil {
			delta.Sub(delta, s.Burn.EIP1559)
		}
		if s.Burn.Blob != nil {
			delta.Sub(delta, s.Burn.Blob)
		}
		if s.Burn.Misc != nil {
			delta.Sub(delta, s.Burn.Misc)
		}
	}

	return delta
}

func (s *supplyInfo) UnmarshalJSON(input []byte) error {
	type Alias supplyInfo
	dec := struct {
		*Alias
	}{
		Alias: (*Alias)(s),
	}
	if err := json.Unmarshal(input, &dec); err != nil {
		return err
	}

	// set default values to big.Int(0), if not set
	if s.Issuance == nil {
		s.Issuance = &supplyInfoIssuance{}
	}
	if s.Issuance.GenesisAlloc == nil {
		s.Issuance.GenesisAlloc = big.NewInt(0)
	}
	if s.Issuance.Reward == nil {
		s.Issuance.Reward = big.NewInt(0)
	}
	if s.Issuance.Withdrawals == nil {
		s.Issuance.Withdrawals = big.NewInt(0)
	}

	if s.Burn == nil {
		s.Burn = &supplyInfoBurn{}
	}
	if s.Burn.EIP1559 == nil {
		s.Burn.EIP1559 = big.NewInt(0)
	}
	if s.Burn.Blob == nil {
		s.Burn.Blob = big.NewInt(0)
	}
	if s.Burn.Misc == nil {
		s.Burn.Misc = big.NewInt(0)
	}

	s.Delta = s.getCalculatedDelta()

	return nil
}
